"use strict";
const stream_1 = require('stream');
const parser_state_1 = require('./parser-state');
const parser_1 = require('./parser');
class Linter {
    constructor(rules, scopes, voids) {
        if (!rules)
            rules = [];
        this.rules = rules;
        this.scopes = scopes;
        this.voids = voids;
    }
    lint(html, path) {
        var parseState = new parser_state_1.ParserState(this.scopes, this.voids);
        var parser = new parser_1.Parser(parseState);
        parseState.initPreRules(parser);
        let rules = this.rules;
        rules.forEach((rule) => {
            rule.init(parser, path);
        });
        parseState.initPostRules(parser);
        var work;
        if (typeof (html) === 'string') {
            var stream = new stream_1.Readable();
            stream.push(html);
            stream.push(null);
            work = stream.pipe(parser);
        }
        else if (this.isStream(html)) {
            work = html.pipe(parser);
        }
        else {
            throw new Error("html isn't pipeable");
        }
        var completed = new Promise(function (resolve, reject) {
            work.on("end", () => {
                parseState.finalise();
                resolve();
            });
        });
        var ruleTasks = [];
        rules.forEach((rule) => {
            let task = completed.then(() => {
                return rule.finalise();
            });
            ruleTasks.push(task);
        });
        return Promise.all(ruleTasks).then(results => {
            var all = new Array();
            results.forEach(parts => {
                all = all.concat(parts);
            });
            all = all.sort((a, b) => (a.line - b.line) * 1000 + (a.column - b.column));
            return all;
        });
    }
    isStream(input) {
        return input.pipe && typeof (input.pipe) === "function";
    }
}
exports.Linter = Linter;

//# sourceMappingURL=linter.js.map
